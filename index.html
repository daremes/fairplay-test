<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="noindex, nofollow" />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: system-ui, sans-serif;
        background: #222;
        padding: 20px;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
      }

      video {
        width: 100%;
        background: #000;
        margin-bottom: 12px;
      }

      .controls {
        display: flex;
        gap: 8px;
      }

      .url-input {
        flex: 1;
        padding: 8px;
        font-size: 14px;
      }

      .load-btn {
        padding: 8px 24px;
        cursor: pointer;
      }

      .log-toggle {
        margin-top: 16px;
        padding: 6px 12px;
        cursor: pointer;
        background: #333;
        color: #ccc;
        border: 1px solid #555;
        font-size: 12px;
      }

      .log-toggle:hover {
        background: #444;
      }

      .log-window {
        margin-top: 8px;
        height: 300px;
        overflow-y: auto;
        background: #111;
        font-family: monospace;
        font-size: 12px;
        padding: 8px;
        color: #ccc;
        display: none;
      }

      .log-window.visible {
        display: block;
      }

      .log-entry {
        white-space: pre-wrap;
        word-break: break-all;
        padding: 2px 0;
      }

      .log-entry.info {
        color: #88f;
      }
      .log-entry.success {
        color: #4f4;
      }
      .log-entry.warning {
        color: #fa0;
      }
      .log-entry.error {
        color: #f44;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <video id="video" controls autoplay playsinline></video>
      <div class="controls">
        <input
          type="text"
          id="manifestUrl"
          class="url-input"
          placeholder="Enter HLS manifest URL..."
        />
        <button id="loadBtn" class="load-btn">Load</button>
      </div>
      <button id="logToggle" class="log-toggle">Show Logs</button>
      <div id="logWindow" class="log-window"></div>
    </div>

    <script>
      // ============================================================
      // CONFIGURATION
      // ============================================================
      const CONFIG = {
        defaultHlsUrl:
          "https://ivys-nw-cdn.o2tv.cz/cdn/uri/get/?token=c6ef0082fcc44f04cca17a7f4f7ae62fb0d6a77d&userId=temp-fp-test&contentId=122&streamType=hls&quality=1080p&contentType=live&region=1&expiry=1797434062&drmOnly=true&skipIpAddressCheck=true&qualityCount=5&encryption=fp",
        licenseUrl: "https://ivys-fpproxy.o2tv.cz/license?access_token=public",
        certificateUrl:
          "https://fs.ceskatelevize.cz/cache/file/mobile/drm/cert/fairplay.cer",
      };

      // ============================================================
      // LOGGING UTILITIES
      // ============================================================
      const MAX_LOGS = 1000;
      const logWindow = document.getElementById("logWindow");

      function addToLogWindow(type, msg, data) {
        // Check if user is near bottom before adding (within 50px)
        const isNearBottom =
          logWindow.scrollHeight -
            logWindow.scrollTop -
            logWindow.clientHeight <
          50;

        const timestamp = new Date().toISOString();
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        let text = `[${timestamp}] ${type.toUpperCase()}: ${msg}`;
        if (data !== undefined) {
          text +=
            " " + (typeof data === "object" ? JSON.stringify(data) : data);
        }
        entry.textContent = text;
        logWindow.appendChild(entry);

        // Keep only last MAX_LOGS entries
        while (logWindow.children.length > MAX_LOGS) {
          logWindow.removeChild(logWindow.firstChild);
        }

        // Auto-scroll only if user was near bottom
        if (isNearBottom) {
          logWindow.scrollTop = logWindow.scrollHeight;
        }
      }

      const log = {
        info: (msg, data) => {
          const timestamp = new Date().toISOString();
          console.log(
            `%c[${timestamp}] INFO: ${msg}`,
            "color: #8888ff",
            data !== undefined ? data : ""
          );
          addToLogWindow("info", msg, data);
        },
        success: (msg, data) => {
          const timestamp = new Date().toISOString();
          console.log(
            `%c[${timestamp}] SUCCESS: ${msg}`,
            "color: #44ff44; font-weight: bold",
            data !== undefined ? data : ""
          );
          addToLogWindow("success", msg, data);
        },
        warning: (msg, data) => {
          const timestamp = new Date().toISOString();
          console.warn(
            `%c[${timestamp}] WARNING: ${msg}`,
            "color: #ffaa00; font-weight: bold",
            data !== undefined ? data : ""
          );
          addToLogWindow("warning", msg, data);
        },
        error: (msg, data) => {
          const timestamp = new Date().toISOString();
          console.error(
            `%c[${timestamp}] ERROR: ${msg}`,
            "color: #ff4444; font-weight: bold",
            data !== undefined ? data : ""
          );
          addToLogWindow("error", msg, data);
        },
        group: (title) => {
          console.group(
            `%c${title}`,
            "color: #ff6b6b; font-size: 14px; font-weight: bold"
          );
          addToLogWindow("warning", `=== ${title} ===`);
        },
        groupEnd: () => {
          console.groupEnd();
        },
        table: (data) => {
          console.table(data);
          addToLogWindow("info", "Table data", data);
        },
        hex: (buffer, maxBytes = 32) => {
          const arr = new Uint8Array(buffer.slice(0, maxBytes));
          return Array.from(arr)
            .map((b) => b.toString(16).padStart(2, "0"))
            .join(" ");
        },
      };

      let certificate = null;
      let currentContentId = null;
      let encryptedEventCount = 0;
      let lastCurrentTime = 0;
      let isSeeking = false;

      const video = document.getElementById("video");
      const manifestUrlInput = document.getElementById("manifestUrl");
      const loadBtn = document.getElementById("loadBtn");

      manifestUrlInput.value = CONFIG.defaultHlsUrl;

      // ============================================================
      // FAIRPLAY CERTIFICATE FETCHING
      // ============================================================
      async function fetchCertificate() {
        log.group("CERTIFICATE FETCH");
        log.info("Fetching FairPlay certificate...");
        log.info("URL:", CONFIG.certificateUrl);

        const startTime = performance.now();

        try {
          const response = await fetch(CONFIG.certificateUrl);
          const fetchTime = (performance.now() - startTime).toFixed(2);

          log.info("Response received", {
            status: response.status,
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers.entries()),
            fetchTimeMs: fetchTime,
          });

          if (!response.ok) {
            throw new Error(
              `Certificate fetch failed: ${response.status} ${response.statusText}`
            );
          }

          const certBuffer = await response.arrayBuffer();

          log.success("Certificate loaded successfully");
          log.info("Certificate details", {
            sizeBytes: certBuffer.byteLength,
            firstBytes: log.hex(certBuffer, 16),
            lastBytes: log.hex(certBuffer.slice(-16), 16),
          });

          log.groupEnd();
          return certBuffer;
        } catch (error) {
          log.error("Certificate fetch failed", {
            message: error.message,
            stack: error.stack,
          });
          log.groupEnd();
          throw error;
        }
      }

      // ============================================================
      // CONTENT ID EXTRACTION
      // ============================================================
      function extractContentId(initData) {
        log.group("CONTENT ID EXTRACTION");
        log.info("Init data size:", initData.byteLength);
        log.info("Init data (hex):", log.hex(initData, 64));

        try {
          const decoder = new TextDecoder("utf-8");
          const initDataString = decoder.decode(initData);

          log.info("Init data as string:", initDataString);

          // Look for SKD URI pattern
          const skdMatch = initDataString.match(/skd:\/\/([^"'\s]+)/);

          if (skdMatch) {
            const contentId = skdMatch[1];
            log.success("Content ID extracted", {
              fullSkdUri: `skd://${contentId}`,
              contentId: contentId,
              contentIdLength: contentId.length,
            });
            log.groupEnd();
            return contentId;
          }

          log.warning("No SKD URI found in init data, using fallback");
          log.groupEnd();
          return "default-content-id";
        } catch (error) {
          log.error("Content ID extraction failed", error);
          log.groupEnd();
          return "default-content-id";
        }
      }

      // ============================================================
      // LICENSE REQUEST FORMATTING
      // ============================================================
      function formatLicenseRequest(spc, contentId, cert) {
        log.group("LICENSE REQUEST FORMATTING");

        const encoder = new TextEncoder();
        const idArray = encoder.encode(contentId);
        const contentIdLength = new Uint8Array([0, 0, 0, 0, idArray.length]);

        const totalSize =
          spc.byteLength +
          contentIdLength.length +
          idArray.length +
          cert.byteLength;
        const combinedArray = new Uint8Array(totalSize);

        let offset = 0;

        // 1. SPC (Server Playback Context)
        combinedArray.set(new Uint8Array(spc), offset);
        log.info("Added SPC", { offset, size: spc.byteLength });
        offset += spc.byteLength;

        // 2. Content ID length (5 bytes)
        combinedArray.set(contentIdLength, offset);
        log.info("Added content ID length field", {
          offset,
          size: contentIdLength.length,
          value: idArray.length,
        });
        offset += contentIdLength.length;

        // 3. Content id (UTF-8 string)
        combinedArray.set(idArray, offset);
        log.info("Added content ID", {
          offset,
          size: idArray.length,
          value: contentId,
        });
        offset += idArray.length;

        // 4. Certificte
        combinedArray.set(new Uint8Array(cert), offset);
        log.info("Added certificate", { offset, size: cert.byteLength });

        log.success("License request payload created", {
          totalSize: combinedArray.byteLength,
          structure: {
            spc: spc.byteLength,
            contentIdLengthField: contentIdLength.length,
            contentId: idArray.length,
            certificate: cert.byteLength,
          },
        });

        log.groupEnd();
        return combinedArray;
      }

      // ===========================================================
      // LICENSE FETCHING
      // ============================================================
      async function getLicense(licenseRequest, contentId) {
        log.group("LICENSE REQUEST");
        log.info("Requesting license from server...");
        log.info("License URL:", CONFIG.licenseUrl);
        log.info("Content ID:", contentId);
        log.info("Payload size:", licenseRequest.byteLength);
        log.info("Payload (first 32 bytes):", log.hex(licenseRequest, 32));

        const startTime = performance.now();

        try {
          const response = await fetch(CONFIG.licenseUrl, {
            method: "POST",
            body: licenseRequest,
          });

          const fetchTime = (performance.now() - startTime).toFixed(2);

          log.info("Response received", {
            status: response.status,
            statusText: response.statusText,
            headers: Object.fromEntries(response.headers.entries()),
            fetchTimeMs: fetchTime,
          });

          if (!response.ok) {
            const errorText = await response.text();
            log.error("License server error response", {
              status: response.status,
              body: errorText.substring(0, 500),
            });
            throw new Error(`License request failed: ${response.status}`);
          }

          const license = await response.arrayBuffer();

          log.success("License (CKC) received", {
            sizeBytes: license.byteLength,
            firstBytes: log.hex(license, 16),
            lastBytes: log.hex(license.slice(-16), 16),
          });

          log.groupEnd();
          return license;
        } catch (error) {
          log.error("License request failed", {
            message: error.message,
            stack: error.stack,
          });
          log.groupEnd();
          throw error;
        }
      }

      // ============================================================
      // VIDEO EVENTS SETUP
      // ============================================================
      function setupVideoEvents() {
        log.group("VIDEO EVENTS SETUP");

        const events = [
          "loadstart",
          "suspend",
          "abort",
          "error",
          "emptied",
          "stalled",
          "loadedmetadata",
          "loadeddata",
          "canplay",
          "canplaythrough",
          "playing",
          "waiting",
          "waitingforkey",
          "seeking",
          "seeked",
          "ended",
          "durationchange",
          "play",
          "pause",
          "ratechange",
          "resize",
          "volumechange",
          "progress",
          "timeupdate",
        ];

        events.forEach((eventName) => {
          video.addEventListener(eventName, (e) => {
            // Calculate buffer ahead of current playback position
            const bufferEnd = video.buffered?.length > 0
              ? video.buffered.end(video.buffered.length - 1)
              : null;
            const bufferAhead = bufferEnd !== null
              ? (bufferEnd - video.currentTime).toFixed(3)
              : null;

            const eventData = {
              type: eventName,
              currentTime: video.currentTime,
              duration: video.duration?.toFixed(2),
              bufferAhead: bufferAhead ? `${bufferAhead}s` : null,
              readyState: video.readyState,
              networkState: video.networkState,
              paused: video.paused,
              ended: video.ended,
              buffered:
                video.buffered?.length > 0
                  ? {
                      start: video.buffered.start(0),
                      end: video.buffered.end(video.buffered.length - 1),
                    }
                  : null,
            };

            // Track seeking state
            if (eventName === "seeking") {
              isSeeking = true;
            } else if (eventName === "seeked") {
              isSeeking = false;
              lastCurrentTime = video.currentTime;
            }

            // Detect currentTime going backward (shouldn't happen during normal playback)
            if (eventName === "timeupdate" && !isSeeking && !video.paused) {
              if (video.currentTime < lastCurrentTime && lastCurrentTime > 0) {
                const timeDiff = lastCurrentTime - video.currentTime;
                log.error(`⚠️ PLAYBACK ANOMALY: currentTime went BACKWARD!`, {
                  previousTime: lastCurrentTime.toFixed(3),
                  currentTime: video.currentTime.toFixed(3),
                  jumpBackward: timeDiff.toFixed(3) + "s",
                  isSeeking,
                  paused: video.paused,
                });
              }
              lastCurrentTime = video.currentTime;
            }

            if (eventName === "error") {
              log.error(`Video event: ${eventName}`, {
                ...eventData,
                errorCode: video.error?.code,
                errorMessage: video.error?.message,
              });
            } else if (
              ["canplay", "playing", "loadeddata", "canplaythrough"].includes(
                eventName
              )
            ) {
              log.success(`Video event: ${eventName}`, eventData);
            } else if (
              ["waiting", "waitingforkey", "stalled", "suspend"].includes(
                eventName
              )
            ) {
              log.warning(`Video event: ${eventName}`, eventData);
            } else {
              log.info(`Video event: ${eventName}`, eventData);
            }

            if (eventName === "loadedmetadata") {
              log.info("Video metadata", {
                videoWidth: video.videoWidth,
                videoHeight: video.videoHeight,
                duration: video.duration,
                currentSrc: video.currentSrc,
              });
            }
          });
        });

        log.success("Video event listeners attached", {
          eventCount: events.length,
        });
        log.groupEnd();
      }

      // ============================================================
      // FAIRPLAY DRM SETUP
      // ============================================================
      function setupFairPlayDRM() {
        log.group("FAIRPLAY DRM SETUP");

        // Check for FairPlay support
        if (!window.WebKitMediaKeys && !navigator.requestMediaKeySystemAccess) {
          log.error("FairPlay not supported in this browser");
          log.info("FairPlay requires Safari browser");
          log.groupEnd();
          return;
        }

        log.success("FairPlay support detected");

        video.addEventListener("encrypted", async (event) => {
          encryptedEventCount++;
          log.group(
            `ENCRYPTED EVENT #${encryptedEventCount} - DRM FLOW INITIATED`
          );
          log.warning("Encrypted content detected!");
          log.info("Encrypted event count:", encryptedEventCount);
          if (encryptedEventCount > 1) {
            log.warning(
              "Multiple encrypted events detected - content may have multiple keys"
            );
          }

          log.info("Event details", {
            initDataType: event.initDataType,
            initDataSize: event.initData?.byteLength,
          });

          if (event.initData) {
            log.info(
              "Init data (first 64 bytes):",
              log.hex(event.initData, 64)
            );
          }

          try {
            // Ensure certificate is loaded
            if (!certificate) {
              log.info("Certificate not cached, fetching...");
              certificate = await fetchCertificate();
            } else {
              log.success("Using cached certificate", {
                sizeBytes: certificate.byteLength,
              });
            }

            // Extract content ID
            currentContentId = extractContentId(event.initData);

            // Request MediaKeySystemAccess
            log.group("MEDIA KEY SYSTEM ACCESS");
            log.info('Requesting access to "com.apple.fps"...');

            const keySystemConfig = {
              initDataTypes: ["skd"],
              videoCapabilities: [
                {
                  contentType: "application/vnd.apple.mpegurl",
                },
              ],
            };

            log.info("Key system configuration", keySystemConfig);

            let keySystemAccess;
            try {
              keySystemAccess = await navigator.requestMediaKeySystemAccess(
                "com.apple.fps",
                [keySystemConfig]
              );

              log.success("MediaKeySystemAccess granted", {
                keySystem: keySystemAccess.keySystem,
                configuration: keySystemAccess.getConfiguration(),
              });

              // Log detailed granted configuration
              const grantedConfig = keySystemAccess.getConfiguration();
              log.info("Granted configuration details", {
                initDataTypes: grantedConfig.initDataTypes,
                videoCapabilities: grantedConfig.videoCapabilities,
                audioCapabilities: grantedConfig.audioCapabilities,
                distinctiveIdentifier: grantedConfig.distinctiveIdentifier,
                persistentState: grantedConfig.persistentState,
                sessionTypes: grantedConfig.sessionTypes,
              });
            } catch (keySystemError) {
              log.error("MediaKeySystemAccess DENIED", {
                name: keySystemError.name,
                message: keySystemError.message,
              });

              // Provide specific guidance based on error
              if (keySystemError.name === "NotSupportedError") {
                log.error("Key system 'com.apple.fps' not supported");
                log.info("Possible reasons:", {
                  notSafari: "FairPlay only works in Safari browser",
                  configRejected: "Requested configuration not supported",
                  initDataType: "Init data type 'skd' may not be supported",
                });

                // Try to detect why it failed
                if (
                  !navigator.userAgent.includes("Safari") ||
                  navigator.userAgent.includes("Chrome")
                ) {
                  log.error(
                    "This browser is NOT Safari - FairPlay requires Safari"
                  );
                }
              } else if (keySystemError.name === "TypeError") {
                log.error("Invalid key system configuration provided");
              } else if (keySystemError.name === "SecurityError") {
                log.error("Security policy prevents EME usage");
                log.info("Check if page is served over HTTPS");
              }

              throw keySystemError;
            }

            // Create MediaKeys
            log.info("Creating MediaKeys object...");
            const mediaKeys = await keySystemAccess.createMediaKeys();
            log.success("MediaKeys created");

            // Set server certificate
            log.info("Setting server certificate...");
            log.info("Certificate size:", certificate.byteLength);
            try {
              const certResult = await mediaKeys.setServerCertificate(
                certificate
              );
              if (certResult === true) {
                log.success("Server certificate set successfully");
              } else if (certResult === false) {
                log.warning("Server certificate was NOT set (returned false)");
                log.warning(
                  "CDM may not support server certificates or certificate was rejected"
                );
              } else {
                log.info("Server certificate set", { result: certResult });
              }
            } catch (certError) {
              log.error("setServerCertificate failed", {
                name: certError.name,
                message: certError.message,
              });
              if (certError.name === "InvalidStateError") {
                log.error("MediaKeys not in valid state for certificate");
              } else if (certError.name === "TypeError") {
                log.error("Invalid certificate format");
              }
              throw certError;
            }

            // Attach to video
            log.info("Attaching MediaKeys to video element...");
            await video.setMediaKeys(mediaKeys);
            log.success("MediaKeys attached to video");

            log.groupEnd(); // MEDIA KEY SYSTEM ACCESS

            // Create session
            log.group("MEDIA KEY SESSION");
            log.info("Creating MediaKeySession...");
            const session = mediaKeys.createSession();
            log.success("Session created", {
              sessionId: session.sessionId || "not assigned yet",
            });

            // MESSAGE event handler
            session.addEventListener("message", async (messageEvent) => {
              log.group("MESSAGE EVENT - LICENSE REQUEST");
              log.warning("SPC generated, need to request license");

              log.info("Message details", {
                messageType: messageEvent.messageType,
                messageSizeBytes: messageEvent.message.byteLength,
              });
              log.info(
                "SPC (first 32 bytes):",
                log.hex(messageEvent.message, 32)
              );

              try {
                // Format license request
                const licenseRequest = formatLicenseRequest(
                  messageEvent.message,
                  currentContentId,
                  certificate
                );

                // Get license
                const license = await getLicense(
                  licenseRequest,
                  currentContentId
                );

                // Update session
                log.info("Updating session with CKC...");
                await session.update(license);
                log.success(
                  "Session updated - decryption keys are now active!"
                );
                log.success("Content can now be decrypted and played");
              } catch (error) {
                log.error("License update failed", {
                  message: error.message,
                  stack: error.stack,
                });
              }

              log.groupEnd(); // MESSAGE EVENT
            });

            // KEY STATUS CHANGE event handler
            session.addEventListener("keystatuseschange", () => {
              log.group("KEY STATUS CHANGE");
              log.warning("DRM key status updated");

              log.info("Total keys in session:", session.keyStatuses.size);

              const keyStatuses = [];
              session.keyStatuses.forEach((status, keyId) => {
                const keyIdArray =
                  keyId instanceof ArrayBuffer
                    ? new Uint8Array(keyId)
                    : new Uint8Array(
                        keyId.buffer,
                        keyId.byteOffset,
                        keyId.byteLength
                      );
                const keyIdHex = Array.from(keyIdArray)
                  .map((b) => b.toString(16).padStart(2, "0"))
                  .join("");

                keyStatuses.push({
                  keyId:
                    keyIdHex.substring(0, 32) +
                    (keyIdHex.length > 32 ? "..." : ""),
                  status: status,
                });

                const keyIdShort = keyIdHex.substring(0, 16) + "...";

                // Log based on key status with explanations
                switch (status) {
                  case "usable":
                    log.success(
                      `Key ${keyIdShort}: USABLE - Key is available for decryption`
                    );
                    break;
                  case "expired":
                    log.error(
                      `Key ${keyIdShort}: EXPIRED - Key has expired and is no longer valid`
                    );
                    break;
                  case "released":
                    log.warning(
                      `Key ${keyIdShort}: RELEASED - Key has been released by the application`
                    );
                    break;
                  case "output-restricted":
                    log.error(
                      `Key ${keyIdShort}: OUTPUT-RESTRICTED - Output restricted (HDCP or similar policy)`
                    );
                    break;
                  case "output-downscaled":
                    log.warning(
                      `Key ${keyIdShort}: OUTPUT-DOWNSCALED - Resolution downscaled due to output policy`
                    );
                    break;
                  case "status-pending":
                    log.info(
                      `Key ${keyIdShort}: STATUS-PENDING - Key status not yet determined`
                    );
                    break;
                  case "internal-error":
                    log.error(
                      `Key ${keyIdShort}: INTERNAL-ERROR - CDM encountered an error`
                    );
                    break;
                  default:
                    log.warning(
                      `Key ${keyIdShort}: ${status.toUpperCase()} - Unknown status`
                    );
                }
              });

              log.table(keyStatuses);

              // Summary of key statuses
              const usableKeys = keyStatuses.filter(
                (k) => k.status === "usable"
              ).length;
              const expiredKeys = keyStatuses.filter(
                (k) => k.status === "expired"
              ).length;
              const restrictedKeys = keyStatuses.filter(
                (k) => k.status === "output-restricted"
              ).length;
              const pendingKeys = keyStatuses.filter(
                (k) => k.status === "status-pending"
              ).length;
              const errorKeys = keyStatuses.filter(
                (k) => k.status === "internal-error"
              ).length;

              log.info("Key status summary", {
                total: keyStatuses.length,
                usable: usableKeys,
                expired: expiredKeys,
                outputRestricted: restrictedKeys,
                pending: pendingKeys,
                errors: errorKeys,
              });

              if (usableKeys > 0) {
                log.success(
                  `${usableKeys} key(s) are USABLE - content can be decrypted`
                );
              } else if (pendingKeys > 0) {
                log.info("Keys are pending - waiting for status update");
              } else if (expiredKeys > 0) {
                log.error("All keys have EXPIRED - license renewal required");
              } else if (restrictedKeys > 0) {
                log.error(
                  "Keys are OUTPUT-RESTRICTED - check HDCP/display security"
                );
              } else if (errorKeys > 0) {
                log.error("Keys have INTERNAL-ERROR - CDM failure");
              } else {
                log.warning("No usable keys - content cannot be decrypted yet");
              }

              // Log session expiration time
              if (session.expiration !== undefined) {
                if (session.expiration === Infinity) {
                  log.info("Session expiration: Never (no expiration set)");
                } else if (session.expiration > 0) {
                  const expirationDate = new Date(session.expiration);
                  const timeUntilExpiry = session.expiration - Date.now();
                  log.info("Session expiration", {
                    expiresAt: expirationDate.toISOString(),
                    timeUntilExpiryMs: timeUntilExpiry,
                    timeUntilExpiryMinutes: (timeUntilExpiry / 60000).toFixed(
                      2
                    ),
                  });
                  if (timeUntilExpiry < 300000) {
                    // Less than 5 minutes
                    log.warning("Session expires in less than 5 minutes!");
                  }
                }
              }

              log.groupEnd(); // KEY STATUS CHANGE
            });

            // SESSION CLOSE event handler (for when session is closed)
            session.closed
              .then(() => {
                log.group("SESSION CLOSED");
                log.warning("MediaKeySession has been closed");
                log.info("Session ID:", session.sessionId || "unknown");
                log.info("This session can no longer be used for decryption");
                log.groupEnd();
              })
              .catch((closeError) => {
                log.group("SESSION CLOSE ERROR");
                log.error("Session closed with error", {
                  name: closeError.name,
                  message: closeError.message,
                });
                log.groupEnd();
              });

            // Generate license request
            log.info("Generating license request...");
            log.info("Init data type:", event.initDataType);
            log.info("Init data size:", event.initData.byteLength);

            try {
              await session.generateRequest(event.initDataType, event.initData);
              log.success(
                "License request generated - waiting for MESSAGE event..."
              );

              // Log session ID after generateRequest (it's often assigned here)
              if (session.sessionId) {
                log.info("Session ID assigned:", session.sessionId);
              } else {
                log.warning(
                  "Session ID still not assigned after generateRequest"
                );
              }
            } catch (genError) {
              log.error("generateRequest failed", {
                name: genError.name,
                message: genError.message,
                code: genError.code,
              });

              // Provide specific guidance based on error
              if (genError.name === "NotSupportedError") {
                log.error("Init data type or format not supported by this CDM");
              } else if (genError.name === "InvalidStateError") {
                log.error("Session is already initialized or closed");
              } else if (genError.name === "QuotaExceededError") {
                log.error(
                  "Too many active sessions - close existing sessions first"
                );
              } else if (genError.name === "TypeError") {
                log.error("Invalid init data provided");
              }
              throw genError;
            }

            log.groupEnd(); // MEDIA KEY SESSION
          } catch (error) {
            log.error("DRM setup failed", {
              name: error.name,
              message: error.message,
              stack: error.stack,
            });
          }

          log.groupEnd(); // ENCRYPTED EVENT
        });

        log.success("Encrypted event listener attached");
        log.groupEnd(); // FAIRPLAY DRM SETUP
      }

      async function loadVideo() {
        const manifestUrl = manifestUrlInput.value.trim();

        if (!manifestUrl) {
          log.error("No manifest URL provided");
          alert("Please enter a manifest URL");
          return;
        }

        log.group("VIDEO LOAD");
        log.warning("Starting video load...");

        log.info("Configuration", {
          manifestUrl: manifestUrl,
          licenseUrl: CONFIG.licenseUrl,
          certificateUrl: CONFIG.certificateUrl,
          userAgent: navigator.userAgent,
        });

        try {
          // Reset video element
          log.info("Resetting video element...");
          video.pause();
          video.removeAttribute("src");
          video.load();

          // Clear existing MediaKeys
          if (video.mediaKeys) {
            log.info("Clearing existing MediaKeys...");
            await video.setMediaKeys(null);
          }

          // Reset certificate cache to ensure fresh DRM flow
          certificate = null;
          currentContentId = null;
          encryptedEventCount = 0;
          lastCurrentTime = 0;
          isSeeking = false;
          log.info(
            "DRM state reset (certificate, contentId, encrypted event counter, time tracking)"
          );

          // Pre-fetch certificate
          log.info("Pre-fetching certificate...");
          certificate = await fetchCertificate();

          // Set video source
          log.info("Setting video source...");
          video.src = manifestUrl;
          log.success("Video source set - waiting for encrypted event...");
        } catch (error) {
          log.error("Video load failed", {
            message: error.message,
            stack: error.stack,
          });
        }

        log.groupEnd(); // VIDEO LOAD
      }

      // ============================================================
      // INITIALIZATION
      // ============================================================
      function init() {
        log.group("INITIALIZATION");
        log.success("FairPlay HLS Test Page loaded");

        log.info("Browser info", {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          vendor: navigator.vendor,
        });

        log.info("Configuration", {
          defaultHlsUrl: CONFIG.defaultHlsUrl.substring(0, 80) + "...",
          licenseUrl: CONFIG.licenseUrl,
          certificateUrl: CONFIG.certificateUrl,
        });

        // Check FairPlay support
        const hasFairPlaySupport = !!(
          window.WebKitMediaKeys || navigator.requestMediaKeySystemAccess
        );
        if (hasFairPlaySupport) {
          log.success("FairPlay DRM support: YES");
        } else {
          log.error(
            "FairPlay DRM support: NO - This page requires Safari browser"
          );
        }

        setupVideoEvents();
        setupFairPlayDRM();

        // Attach load button handler
        loadBtn.addEventListener("click", loadVideo);
        log.info("Load button handler attached");

        // Attach log toggle button handler
        const logToggle = document.getElementById("logToggle");
        logToggle.addEventListener("click", () => {
          const isVisible = logWindow.classList.toggle("visible");
          logToggle.textContent = isVisible ? "Hide Logs" : "Show Logs";
          if (isVisible) {
            logWindow.scrollTop = logWindow.scrollHeight;
          }
        });
        log.info("Log toggle handler attached");

        // Allow Enter key in input to trigger load
        manifestUrlInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            loadVideo();
          }
        });
        log.info("Enter key handler attached");

        log.success("Initialization complete");
        log.info('Click "Load" button or press Enter to start playback');
        log.groupEnd(); // INITIALIZATION
      }

      init();
    </script>
  </body>
</html>
